### 屏幕采集
#### 功能实现步骤
1. 弹窗申请屏幕录制的权限
```java
// 以下代码可以放在MainActivity中
    static final int RECORD_REQUEST_CODE = 201;
    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    void startCapture(Surface surface)
    {
        mediaProjectionManager = (MediaProjectionManager)getSystemService(MEDIA_PROJECTION_SERVICE);
        Intent intent = mediaProjectionManager.createScreenCaptureIntent();
        startActivityForResult(intent, RECORD_REQUEST_CODE);
        mSurface = surface;
    }
```
2. 用户授权同意后，启动一个前台服务用于getMediaProjection
```java
// 以下代码可以放在MainActivity中
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode==RECORD_REQUEST_CODE && resultCode==RESULT_OK)
        {
            if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O)
            {
                Log.i("ScreenCap:", "start ScreenCapService.");
                Intent svc = new Intent(this, ScreenCapService.class);
                svc.putExtra("data", data);
                svc.putExtra("resultCode", resultCode);
                svc.putExtra("surface", mSurface);
                startForegroundService(svc);
            }
            else
            {
                Log.i("ScreenCap:", "start getMediaProjection.");
                mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, data);
                int w = 1920;
                int h = 1080;
                Log.i("ScreenCap:", "createVirtualDisplay.w="+w+" h="+h);
                virDisplay = mediaProjection.createVirtualDisplay("RECORDER_VIR_DISPLAY_0", w, h, 1,
                        DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC, mSurface, virDisplayCallback, null);
            }
        }
    }
```
3. 在前台服务的onStartCommand方法中调用getMediaProjection以及createVirtualDisplay
    在createVirtualDisplay时可以传入Surface对象，如果该Surface是从SurfaceView中获取，则可以直接预览屏幕采集的内容。如果该Surface是从MediaCodec.getInputSurface中获取的，则可以直接将屏幕采集内存传入编码器中进行编码

##### 前端Service
+ foregroundService的限制：Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。
在系统创建服务后，应用有五秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。
如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。

##### 实践经验汇总
+ 在 targetSdkVersion 大于等于29时，系统加强了对屏幕采集的限制，必须先启动相应的前台 Service，才能正常调用 getMediaProjection 方法，否则会抛异常。就是需要在front service里面调用getMediaProjection才行，否则会抛出异常。异常信息：java.lang.SecurityException: Media projections require a foreground service of type ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PROJECTION

##### 具体实现
[screen capture/graber demo](https://github.com/zhuqingquan/code-test/testAdrScreenCaptur)

##### 好用的参考文档
[深入浅出，Andorid 端屏幕采集技术实践](https://zhuanlan.zhihu.com/p/372238406)--很好的实践总结，其中包含了关于使用不同来源的Surface用于MediaProjection。
[如何解决Android10 屏幕录制报错](https://zhuanlan.zhihu.com/p/360356420)--这个里面包含了比较清晰的过程描述
[这个关于解决getMediaProjection时抛异常](https://blog.csdn.net/qq_36332133/article/details/96485285)
[包含屏幕采集以及编码的demo代码库](https://github.com/yrom/ScreenRecorder)
[Android基础总结六：Sevice](https://blog.csdn.net/shift_wwx/article/details/9952045)
[Android入门教程 | 四大组件之Service（前台服务，后台服务）](http://blog.itpub.net/70008155/viewspace-2809902/)

### MediaCodec编码
#### 创建与初始化编码器
+ 可以通过直接指定codec名称创建(MediaCodec.createByCodecName)或者通过MimeType进行创建(MediaCodec.createEncoderByType)。
+ 编码视频的分辨率受限于编码器的能力，所以应该在初始化之前进行检查。这样就会产生一个实际生效的编码分辨率，应该提供接口让用户获取这个分辨率。

#### 停止编码器
+ 如果使用是InputSurface，则应该使用MediaCodec.signalEndOfInputStream通知codec不再从InputSurface中获取数据用于编码。然后在MediaCodec.Callback.onOutputBufferAvailable回调中处理流的结束帧。并stop、release。
+ 如果使用ByteBuffer

#### MediaCodec编码中的输入帧Surface
+ When using an input Surface, there are no accessible input buffers, as buffers are automatically passed from the input surface to the codec.使用Surface作为编码器帧的输入数据时，编码器直接从Surface中获取（拷贝？？？）数据。
来源： 
1. MediaCodec.createInputSurface创建
2. [MediaCodec.setInputSurface](https://developer.android.google.cn/reference/android/media/MediaCodec#setInputSurface(android.view.Surface))设置从外部创建或者通过[MediaCodec.createPersistentInputSurface](https://developer.android.google.cn/reference/android/media/MediaCodec#createPersistentInputSurface())创建的Surface对象
    MediaCodec.setInputSurface只能设置PersistentSurface，否则会抛出异常。可以调用MediaCodec.createPersistentInputSurface接口创建此Surface。猜测可以使用EGL创建类似的PersistentSurface。
    ```
    java.lang.RuntimeException: Failure delivering result ResultInfo{who=null, request=201, result=-1, data=Intent { (has extras) }} to activity {com.example.testadrscreencapture/com.example.testadrscreencapture.MainActivity}: java.lang.IllegalArgumentException: not a PersistentSurface
    ```
**注意：当使用了上面2个接口设置InputSurface，之后MediaCodec.Callback.onInputBufferAvailable是不会触发的。**

#### 获取InputBuffer
MediaCodec.dequeueInputBuffer
MediaCodec.Callback.onInputBufferAvailable

#### 具体实现
[screen capture/graber demo](https://github.com/zhuqingquan/code-test/tree/master/testAdrScreenCapture)内的VideoEncoder类

#### 编码备忘
+ [MediaCodec.configure](https://developer.android.google.cn/reference/android/media/MediaCodec#configure(android.media.MediaFormat,%20android.view.Surface,%20android.media.MediaCrypto,%20int))时传入的Surface是解码时渲染的Surface，不用于编码。
+ Going back to Flushed state is only supported for decoders, and may not work for encoders (the behavior is undefined).

### MediaCodec解码

#### 输出解码后帧
+ Also since (/reference/android/os/Build.VERSION_CODES#M), you can change the output Surface dynamically using [MediaCodec.setOutputSurface](https://developer.android.google.cn/reference/android/media/MediaCodec#setOutputSurface(android.view.Surface))
+ When using an output Surface, you can select whether or not to render each output buffer on the surface. You have three choices:
    + Do not render the buffer: call releaseOutputBuffer(bufferId, false)
    + Render the buffer with the default timestamp: call releaseOutputBuffer(bufferId, true)
    + Render the buffer with a specific timestamp: call releaseOutputBuffer(bufferId, timestamp)
    由此可知，解码后的帧需要将内容复制到通过MediaCodec.setOutputSurface(surface)接口设置的输出Surface上面，也是通过多渲染一次完成的。

### 屏幕采集与编码的集成
+ 在屏幕采集时可以创建一个SurfaceView，并获取SurfaceView内的Surface用于创建VirtualDisplay，这样可以在SurfaceView中预览屏幕采集的画面。但是这个Surface不能再通过MediaCodec.setInputSurface用于编码，因为这个不是PersistentSurface。

### Android中的Surface
#### 3种Surface来源
+ SurfaceView中自带的Surface。通过SurfaceHolder获取。
+ 以EGL的TextureID创建的Surface。
+ MediaCodec.createInputSurface以及MediaCodec.createPersistentSurafce创建的Surface

### Android渲染相关源码
+ surfaceflinger service。目录/frameworks/native/services/surfaceflinger/。[surfaceflinger-xref](http://androidxref.com/7.0.0_r1/xref/frameworks/native/services/surfaceflinger/)
+ HAL层由设备制造商实现并提供的FrameBuffer或者gralloc的实现。分别为hardware/fb.h、hardware/gralloc.h。[fb.h-xref](http://androidxref.com/7.0.0_r1/xref/hardware/libhardware/include/hardware/fb.h)[gralloc.h-xref](http://androidxref.com/7.0.0_r1/xref/hardware/libhardware/include/hardware/gralloc.h)
+ 高通820 MSM8996设备提供的gralloc实现。可以作为gralloc实现的例子看看。目录hardware/qcom/display/msm8996。[libgralloc-xref](http://androidxref.com/7.0.0_r1/xref/hardware/qcom/display/msm8996/libgralloc/)
+ Android中实现的Opengl库，包含EGL的实现。目录frameworks/native/opengl[opengl-xref](http://androidxref.com/7.0.0_r1/xref/frameworks/native/opengl/)
+ ANativeWindow接口的定义，文件system/core/include/system/window.h。[system/window.h](http://androidxref.com/7.0.0_r1/xref/system/core/include/system/window.h)
