### 调试技巧
#### 使用logcat查看日志
adb logcat | grep MyApp
adb logcat | grep -i myapp #忽略大小写。
可以看出 tag 是一行开头的第三个字符开始，根据这点写出表达式：
^符号表示句子开头
adb logcat | grep "^..MyApp"
根据这个格式也可以设置只显示某个优先级的 log，再匹配行首第一个字符即可。例如仅显示 Error 级别 tag 为 MyApp 的输出：
adb logcat | grep "^E.MyApp"
显示同一个进程的所有输出
```
#!/bin/bash
packageName=$1
pid=`adb shell ps | grep $packageName | awk ‘{print $2}’`
adb logcat | grep –color=auto $pid
```

#### 屏幕采集截屏
步骤
1. 弹窗申请屏幕录制的权限
```java
// 以下代码可以放在MainActivity中
    static final int RECORD_REQUEST_CODE = 201;
    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    void startCapture(Surface surface)
    {
        mediaProjectionManager = (MediaProjectionManager)getSystemService(MEDIA_PROJECTION_SERVICE);
        Intent intent = mediaProjectionManager.createScreenCaptureIntent();
        startActivityForResult(intent, RECORD_REQUEST_CODE);
        mSurface = surface;
    }
```
2. 用户授权同意后，启动一个前台服务用于getMediaProjection
```java
// 以下代码可以放在MainActivity中
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode==RECORD_REQUEST_CODE && resultCode==RESULT_OK)
        {
            if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O)
            {
                Log.i("ScreenCap:", "start ScreenCapService.");
                Intent svc = new Intent(this, ScreenCapService.class);
                svc.putExtra("data", data);
                svc.putExtra("resultCode", resultCode);
                svc.putExtra("surface", mSurface);
                startForegroundService(svc);
            }
            else
            {
                Log.i("ScreenCap:", "start getMediaProjection.");
                mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, data);
                int w = 1920;
                int h = 1080;
                Log.i("ScreenCap:", "createVirtualDisplay.w="+w+" h="+h);
                virDisplay = mediaProjection.createVirtualDisplay("RECORDER_VIR_DISPLAY_0", w, h, 1,
                        DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC, mSurface, virDisplayCallback, null);
            }
        }
    }
```
3. 在前台服务的onStartCommand方法中调用getMediaProjection以及createVirtualDisplay

##### 前端Service
+ foregroundService的限制：Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。
在系统创建服务后，应用有五秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。
如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。

##### 实践经验汇总
+ 在 targetSdkVersion 大于等于29时，系统加强了对屏幕采集的限制，必须先启动相应的前台 Service，才能正常调用 getMediaProjection 方法，否则会抛异常。就是需要在front service里面调用getMediaProjection才行，否则会抛出异常。异常信息：java.lang.SecurityException: Media projections require a foreground service of type ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PROJECTION
+ 

##### 好用的参考文档
[深入浅出，Andorid 端屏幕采集技术实践](https://zhuanlan.zhihu.com/p/372238406)--很好的实践总结，其中包含了关于使用不同来源的Surface用于MediaProjection。
[如何解决Android10 屏幕录制报错](https://zhuanlan.zhihu.com/p/360356420)--这个里面包含了比较清晰的过程描述
[这个关于解决getMediaProjection时抛异常](https://blog.csdn.net/qq_36332133/article/details/96485285)
[包含屏幕采集以及编码的demo代码库](https://github.com/yrom/ScreenRecorder)
[Android基础总结六：Sevice](https://blog.csdn.net/shift_wwx/article/details/9952045)
[Android入门教程 | 四大组件之Service（前台服务，后台服务）](http://blog.itpub.net/70008155/viewspace-2809902/)

#### UI
#### LinearLayout
[官方文档](https://developer.android.com/guide/topics/ui/layout/linear?hl=zh-cn)
布局方式：
+ 均等分布
如要创建线性布局，让每个子视图使用大小相同的屏幕空间，请将每个视图的 android:layout_height 设置为 "0dp"（针对垂直布局），或将每个视图的 android:layout_width 设置为 "0dp"（针对水平布局）。然后，请将每个视图的 android:layout_weight 设置为 "1"。

+ 不等分布
您也可创建线性布局，让子元素使用大小不同的屏幕空间：
    - 如果有三个文本字段，其中两个声明权重为 1，另一个未赋予权重，那么没有权重的第三个文本字段就不会展开，而仅占据其内容所需的区域。另一方面，另外两个文本字段将以同等幅度展开，填充测量三个字段后仍剩余的空间。
    - 如果有三个文本字段，其中两个字段声明权重为 1，而为第三个字段赋予权重 2（而非 0），那么现在相当于声明第三个字段比另外两个字段更为重要，因此，该字段将获得总剩余空间的一半，而其他两个字段均享余下的空间。

#### Java零散语法
##### 将byte[] array 转换成 int[] array
```java
    byte[] data = new byte[300 * 200 * 4];
    IntBuffer intBuf = ByteBuffer.wrap(data).order(ByteOrder.BIG_ENDIAN).asIntBuffer();
    int[] array = new int[intBuf.remaining()];
    intBuf.get(array);
```

#### adb命令run-as
[参考](http://adbcommand.com/articles/%E5%B8%B8%E7%94%A8adb%20shell%E5%91%BD%E4%BB%A4%EF%BC%9Arun-as%E5%92%8Cexec-out)
```
adb shell "run-as com.sample.foo sh -c 'cp /sdcard/sample.db /data/data/com.sample.foo/databases/sample.db'"
```

#### 摄像头相关
[官方API文档](https://developer.android.com/reference/android/hardware/Camera.html)

#### 写日志
```java
Log.v(TAG, "index=" + i);
```

#### 重载Activity的onConfigurationChanged方法
需要修改AndroidManifest.xml里面activity的属性，添加以下属性之后，onConfigurationChanged才会回调。重点应该是orientation与screenSize需要同时配置。
```
// 手机横竖屏切换时，以下配置activity不会重新创建，onConfigurationChanged将被调用
android:configChanges="orientation|keyboardHidden|screenSize"

// 手机横竖屏切换时，以下配置activity重新创建，onConfigurationChanged不调用
android:configChanges="keyboardHidden|screenSize"
android:configChanges="orientation|keyboardHidden"
```
[参考资料](https://cloud.tencent.com/developer/article/1740063)

#### 获取手机屏幕的旋转方向
```
Display display = activity.getWindowManager().getDefaultDisplay();
int rotation = display.getRotation();
//
// rotation 的值表示了当前屏幕的旋转角度，可能的值有:
// Surface.ROTATION_0、Surface.ROTATION_90、
// Surface.ROTATION_180、Surface.ROTATION_270。
//
switch (display.getRotation()) {
    case Surface.ROTATION_0:
        break;
    case Surface.ROTATION_90:
        break;
    case Surface.ROTATION_180:
        break;
    case Surface.ROTATION_270:
        break;
}
```

#### gradle下载的依赖包存放的路径
第三方包存放在：~/.gradle/caches/modules-2/files-2.1/...

安卓系统包存放在：Android/Sdk

#### 本地aar包
在module的build.gradle文件中添加
```
repositories {
    flatDir {
        dirs 'libs'
    }
}

dependencies {
    implementation(name:'xxx-debug', ext:'aar')
    //或
    implementation(name:'xxx-debug', ext:'jar')
}

// 还有，不要忘了在主工程中也添加依赖！在app的build.gradle添加：
repositories {
    flatDir {
        dirs project(':你的Module名').file('libs')
    }
}

```

#### gradle maven本地源
[阿里云Maven中央仓库](https://developer.aliyun.com/mvn/guide?spm=a2c40.maven_devops2020_goldlog_.0.0.275c3054yut6Ld)

#### android studio设置或者清除http proxy代理、gradle代理
方法1： 在settings-->System Settings-->HTTP proxy中设置IDE的全局代理。包括了gradle的代理。
方法2： 在gradle的全局配置文件.gradle/gradle.properties中修改关于http proxy代理的设置。
**清除代理的配置**
注意：除了在配置的地方修改，删除配置信息之外。还需要清理对应的gradle缓存才能真正清理。
1. 删除掉.cache/Google/AndroidStudio* 目录会更保险一点
2. 清理项目重新sync构建

#### APP程序崩溃获取崩溃堆栈
1. 当程序崩溃时，可以通过查看第三方应用异常记录，记录里面会有崩溃堆栈的内容。小米位于“三方应用分析”。
2. 获取到崩溃的堆栈可能只是有地址，而没有符号名，此时可以使用addr2line进行分析。


### Android studio编译构建报错解决
+ **Task 'testClasses' not found**
报错信息：
* What went wrong:
Task 'testClasses' not found in project ':module-b'.
解决方法：
在module-b的build.gradle中添加以下代码：
task testClasses {
    doLast {
        println 'This is a dummy testClasses task'
    }
}
Kotlin DSL：
task("testClasses").doLast {
    println("This is a dummy testClasses task")
}

+ **需要更新test库版本**
报错信息：
android:exported needs to be explicitly specified for element <activity#androidx.test.core.app.InstrumentationActivityInvoker$BootstrapActivity>. Apps targeting Android 12 and higher are required to specify an explicit value for `android:exported` when the corresponding component has an intent filter defined.
解决方式--将报错的项目的单元测试库更新
dependencies {
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}

+ **Android引用三方库导致SO库冲突**
错误信息：
2 files found with path 'lib/arm64-v8a/libc++_shared.so' from inputs:
If you are using jniLibs and CMake IMPORTED targets, see
https://developer.android.com/r/tools/jniLibs-vs-imported-targets
解决办法
在app的build.gradle 的android{}节点中添加下面内容。
```
    packagingOptions {
        pickFirst 'lib/x86/libc++_shared.so'
        pickFirst 'lib/x86_64/libc++_shared.so'
        pickFirst 'lib/arm64-v8a/libc++_shared.so'
        pickFirst 'lib/armeabi-v7a/libc++_shared.so'
    }
```

### android的native library
[官方文档](https://source.android.google.cn/docs/core/permissions/namespaces_libraries?hl=en)
In addition to standard public native libraries, silicon vendors (starting from Android 7.0) and device manufacturers (starting from Android 9) may choose to provide additional native libraries accessible to apps by putting them under the respective library folders and explicitly listing them in .txt files.

The library folders are:

+ /vendor/lib (for 32-bit) and /vendor/lib64 (for 64-bit) for libraries from silicon vendors
+ /system/lib (for 32-bit) and /system/lib64 (for 64-bit) for libraries from device manufacturers

The .txt files are:
+ /vendor/etc/public.libraries.txt for libraries from silicon vendors
+ /system/etc/public.libraries-COMPANYNAME.txt for libraries from device manufacturers, where COMPANYNAME refers to a name of the manufacturer (such as awesome.company). COMPANYNAME must match with [A-Za-z0-9_.-]+; alphanumeric characters, _, . (dot) and -. It is possible to have multiple such .txt files in a device if some libraries are from external solution providers.

#### 手机上查看当前设备有哪些silicon或者device manufactures导出的动态库
```
adb shell cat /vendor/etc/public.libraries.txt
adb shell cat /system/etc/public.libraries-xiaomi.txt
adb shell cat /system/etc/public.libraries.txt
adb shell cat /system/etc/public.libraries-qti.txt
```